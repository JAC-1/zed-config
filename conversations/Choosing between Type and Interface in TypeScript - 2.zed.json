{"id":"9300ec50-85df-4e53-865d-9eb9a7151e4c","zed":"context","version":"0.4.0","text":"\n```ts nextjs-dashboard/app/lib/definitions.ts:19-28\n\n// Excerpt from: \nexport type Invoice = {\n  id: string;\n  customer_id: string;\n  amount: number;\n  date: string;\n  // In TypeScript, this is called a string union type.\n  // It means that the \"status\" property can only be one of the two strings: 'pending' or 'paid'.\n  status: 'pending' | 'paid';\n};\n\n```\n\nWhy type and not interface?\n\nIn TypeScript, both `type` and `interface` can be used to define the shape of an object, but there are some differences between them. Here are a few reasons why you might choose `type` over `interface` in this context:\n\n1. **Union Types**: `type` can be used to define union types, which is useful when you want to define a type that can be one of several different types. For example, you can define a type that is either a string or a number:\n   ```ts\n   type StringOrNumber = string | number;\n   ```\n\n2. **Intersection Types**: `type` can also be used to define intersection types, which combine multiple types into one. For example:\n   ```ts\n   type A = { a: string };\n   type B = { b: number };\n   type C = A & B; // { a: string, b: number }\n   ```\n\n3. **Primitive Types**: `type` can be used to create aliases for primitive types, which is not possible with `interface`. For example:\n   ```ts\n   type ID = string;\n   ```\n\n4. **Complex Types**: `type` can be used to define more complex types, such as tuples and mapped types, which are not possible with `interface`. For example:\n   ```ts\n   type Tuple = [string, number];\n   ```\n\n5. **Literal Types**: `type` can be used to define literal types, which is useful for defining exact values that a variable can take. For example:\n   ```ts\n   type Status = 'pending' | 'paid';\n   ```\n\nIn the case of the `Invoice` type, it includes a string union type for the `status` property (`'pending' | 'paid'`). While you can achieve similar functionality with `interface` by using string literal types, using `type` is often more straightforward and concise for such cases.\n\nHere's how you might define the same shape using `interface`:\n```ts\ninterface Invoice {\n  id: string;\n  customer_id: string;\n  amount: number;\n  date: string;\n  status: 'pending' | 'paid';\n}\n```\n\nBoth `type` and `interface` would work in this case, but `type` is often preferred for its simplicity and flexibility, especially when dealing with union and intersection types.\n\n```ts nextjs-dashboard/app/lib/definitions.ts:19-28\n// Excerpt from: \nexport type Invoice = {\n  id: string;\n  customer_id: string;\n  amount: number;\n  date: string;\n  // In TypeScript, this is called a string union type.\n  // It means that the \"status\" property can only be one of the two strings: 'pending' or 'paid'.\n  status: 'pending' | 'paid';\n};\n\n```\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":56}},"image_offsets":[]},{"id":{"replica_id":0,"value":25},"start":389,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":57}},"image_offsets":[]},{"id":{"replica_id":0,"value":26},"start":2382,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":58}},"image_offsets":[]}],"summary":"Choosing between Type and Interface in TypeScript","slash_command_output_sections":[]}